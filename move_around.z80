
;longwait equ 0x10
wait equ 0x6E
longwait equ 0x85
charout equ 0xa1
drawchar equ 0x8F
cleardisplay equ 0x10a
raw_textout equ 0xe4
app_ret equ 0x35b
; loads serial input into E register
wait_serial equ 0x484
pioout equ $008F
DSP_IW equ 0b00000001
; set carret anywhere on the screen
; b - offset, 64 (0x40) is 2nd line
; c - offset on the line
set_carret_raw equ 0x12F
DSP_DW	equ	0b00000101
SERA 	equ 0x8
SERAC 	equ 0xa

SERB 	equ 0x9
SERBC 	equ 0xb

; NumToHex converter
; a - input
; de - output in Hex format
NumToHex equ 0x2A5

#target bin
#code _CODE, 0x882, 0x6fe	; 0x882 is the allocated memory for application of size 0x6fe (2 bytes reserved for app size)
#code _CODE

; app entry point
	jp main

xpos defb 0
ypos defb 0

rawout:
	ld d, DSP_DW
	call pioout
	ret

moveup:
	ld hl, ypos
	ld a, (hl)
	or 0
	ret z
	dec (hl)
	ret

movedown:
	ld hl, ypos
	ld a, (hl)
	sub 1
	ret z
	inc (hl)
	ret

moveleft:
	ld hl, xpos
	ld a, (hl)
	or 0
	ret z
	dec (hl)
	ret

moveright:
	ld hl, xpos
	ld a, (hl)
	sub 15
	ret z
	inc (hl)
	ret
 
reset_2nd_line:
	push bc
	ld b, 64
	ld c, 0
	call set_carret_raw
	pop bc
	ret

OutHex:
	push bc
	push de
	call NumToHex
	ld bc, de
	ld d, DSP_DW
	ld e, b
	call drawchar
	ld e, c
	call drawchar
	pop de
	pop bc
	ret

output_keycode:
	push bc
	push de
	push hl
#local
	; output currently pressed key code on the 2nd line of lcd
	ld b, 64
	ld c, 0
	call set_carret_raw

	ld hl, keystroke
	; quick check if we have any keystroke chars
	ld a, (hl)
	or 0
	jp z, done
	ld b, a
	inc hl
outcode:	
	ld a, (hl)
	call OutHex
	inc hl
	djnz outcode

done:	
#endlocal
	; transform A register to d & e codes
	pop hl
	pop de
	pop bc
	ret

move:
#local
	ld a, (keystroke + 1)

	; check that we start with 5b
	sub 0xf0
	ret nz

	ld a, (keystroke + 2)

	push af
	sub 6bh
	call z, moveleft
	pop af

	push af
	sub 74h
	call z, moveright
	pop af

	push af
	sub 75h
	call z, moveup
	pop af

	push af
	sub 72h
	call z, movedown
	pop af

#endlocal
	ret

reset_pos:
	push hl
	ld hl, xpos
	ld (hl), 0
	ld hl, ypos
	ld (hl), 0
	pop hl
	ret

draw_player:
	push bc
	push hl
	push de
#local
	ld a, (ypos)
	ld b, a
	ld a, 0
moverow:
	add a, 64
	djnz moverow
	ld b, a
	
	ld hl, xpos
	ld c, (hl)

	call set_carret_raw

	ld e, '#'
	ld d, DSP_DW
	call drawchar

#endlocal
	pop de
	pop hl
	pop bc
	ret

draw_player_location:
	ld b, 64
	ld c, 9
	call set_carret_raw

	ld d, DSP_DW
	ld e, '['
	call drawchar

	ld a, (xpos)
	call OutHex

	ld e, ','
	call drawchar

	ld a, (ypos)
	call OutHex

	ld d, DSP_DW
	ld e, ']'
	call drawchar

	ret	

main:
	call init_ps2_keyboard
	call cleardisplay
	call reset_pos
	call disablecursor


runloop:
	call cleardisplay

	call output_keycode

	; render
	call draw_player_location
	call draw_player

	; wait for input
	;call wait_keystroke

	call wait_ps2_scancode

	; move
	call move

	jp runloop

exit:
	;halt
	jp app_ret




; TODO: move to BIOS
disablecursor:
	; hide cursor
	ld d, DSP_IW
	ld e, 0b00001100
	call pioout
	ret

; move to BIOS
keystroke defs 4, 00h
wait_keystroke:
	push hl
	push bc
	push de
	ld hl, keystroke
#local	
	ld (hl), 3
	inc hl
	ld (hl), 0
	inc hl
	ld (hl), 0
	inc hl
	ld (hl), 0
	ld hl, keystroke

; we wait for at least one keycode
poll:
	in a, (SERAC)
	bit 0, a
	jr z, poll

	ld b, 0
	inc b
	; we have a valid first code so increment hl[0] to 1
	; load the code into hl[1]
	inc hl
	in a, (SERA)
	ld (hl), a

	;jp done
	; is there a 2nd keycode right away?
	in a, (SERAC)
	bit 0, a
	jp z, done

	inc b
	inc hl

	in a, (SERA)
	ld (hl), a

	; is there a 3rd keycode right away?
	in a, (SERAC)
	bit 0, a
	jp z, done

	inc b
	inc hl

	in a, (SERA)
	ld (hl), a

done:
#endlocal
	ld hl, keystroke
	ld (hl), b
	pop de
	pop bc
	pop hl
	ret


PS2_SERIAL_INIT
	defb 0, 0b00011000	; WR0, channel reset
	defb 4, 0b00000101  ; WR4, odd parity, 1 stop bit, x1 clock mode coming from keyboard
	defb 3, 0b11000001	; WR3, Rx enable, Rx 8 bits /char
	defb 5, 0b01101000	; WR5, Tx enable, Tx 8 bitts char
	defb 1, 0b10000000	; WR1, Wait/Ready on R/T enable 

init_ps2_keyboard:
	push hl
	push bc

	ld hl, PS2_SERIAL_INIT
	ld b, 10	; size of serial init code 5 registers(a byte address) x 1 byte config
	ld c, SERBC
	otir

	pop bc
	pop hl
	ret


; waits on a scancode via serial port B that is wired up to PS/2 keyboard
scancode defs 4, 00h
wait_ps2_scancode:
	push hl
	push bc
	push de
	ld hl, scancode
	ld (hl), 3
	inc hl
	ld (hl), 0
	inc hl
	ld (hl), 0
	inc hl
	ld (hl), 0
	ld hl, keystroke

#local
poll:
	in a, (SERBC)
	bit 0, a
	jr z, poll

	ld b, 0
	inc b
	; we have a valid first code so increment hl[0] to 1
	; load the code into hl[1]
	inc hl
	in a, (SERB)
	ld (hl), a

	;jp done
	; is there a 2nd scancode right away?
	in a, (SERBC)
	bit 0, a
	jp z, done

	inc b
	inc hl

	in a, (SERB)
	ld (hl), a

	; is there a 3rd scancode right away?
	in a, (SERBC)
	bit 0, a
	jp z, done

	inc b
	inc hl

	in a, (SERB)
	ld (hl), a

done:
	ld hl, keystroke
	ld (hl), b
#endlocal
	pop de
	pop bc
	pop hl
	ret


